var compilerOptions = systemOptions.register(new OptionSet("Compiler Options"));
var enableOpt = compilerOptions.register(new Option("opt", "optimizations", "boolean", false, "Enable optimizations."));
var enableVerifier = compilerOptions.register(new Option("verify", "verify", "boolean", false, "Enable verifier."));
var enableInlineCaching = compilerOptions.register(new Option("ic", "inlineCaching", "boolean", false, "Enable inline caching."));
var traceInlineCaching = compilerOptions.register(new Option("tic", "traceInlineCaching", "boolean", false, "Trace inline caching execution."));

var compilerEnableExceptions = compilerOptions.register(new Option("cex", "exceptions", "boolean", false, "Compile functions with catch blocks."));
var compilerMaximumMethodSize = compilerOptions.register(new Option("cmms", "maximumMethodSize", "number", 4 * 1024, "Compiler maximum method size."));

/**
 * Checks if the specified method should be compiled. For now we just ignore very large methods.
 */
function shouldCompile(mi) {
  if (mi.hasExceptions() && !compilerEnableExceptions.value) {
    return false;
  } else if (mi.code.length > compilerMaximumMethodSize.value) {
    return false;
  }
  return true;
}

var T = estransform;

var Literal = T.Literal;
var Identifier = T.Identifier;
var VariableDeclaration = T.VariableDeclaration;
var VariableDeclarator = T.VariableDeclarator;
var MemberExpression = T.MemberExpression;
var BinaryExpression = T.BinaryExpression;
var SequenceExpression = T.SequenceExpression;
var CallExpression = T.CallExpression;
var AssignmentExpression = T.AssignmentExpression;
var ExpressionStatement = T.ExpressionStatement;
var ReturnStatement = T.ReturnStatement;
var Program = T.Program;
var Statement = T.Statement;
var FunctionDeclaration = T.FunctionDeclaration;
var FunctionExpression = T.FunctionExpression;
var ConditionalExpression = T.ConditionalExpression;
var ObjectExpression = T.ObjectExpression;
var ArrayExpression = T.ArrayExpression;
var UnaryExpression = T.UnaryExpression;
var NewExpression = T.NewExpression;
var UpdateExpression = T.UpdateExpression;
var ForStatement = T.ForStatement;
var BlockStatement = T.BlockStatement;
var ThisExpression = T.ThisExpression;
var TypeAliasDirective = T.TypeAliasDirective;
var CastExpression = T.CastExpression;
var ThrowStatement = T.ThrowStatement;
var IfStatement = T.IfStatement;
var WhileStatement = T.WhileStatement;
var BreakStatement = T.BreakStatement;
var ContinueStatement = T.ContinueStatement;
var SwitchStatement = T.SwitchStatement;
var SwitchCase = T.SwitchCase;
var TryStatement = T.TryStatement;
var CatchClause = T.CatchClause;

/**
 * When adding a new "magic" variable that the compiler has
 * a fixed constant for, please add it as a global identifier
 * instead of using id("$foo") in the code.
 *
 * Please make sure that magic variable identifiers start with
 * a '$' so that they cannot collide with any identifiers in the
 * method itself.
 *
 * Variable prefix scheme:
 *   * All variables in compiled code that start with a '$' are
 *     reserved for the compiler's internal use and should be
 *     closed in this list.
 *
 *   * All argument names are prefixed with an "a"
 *
 *   * The remaining locals that are not arguments reserve the
 *     names 'a' through 'z', after which they go to a scheme where
 *     they are prefixed with a "l".
 *
 *   * Temporary variables generated by the compiler to optimize
 *     code to CSE purposes and potentially other reasons are
 *     prefixed by a "v".
 *
 *   * Temporary variables generated by the compiler to sometimes
 *     store stack values when needed are of the format "s%d"
 *     where the "%d" is the stack index that the value occupies.
 */

var VAR_PREFIX = "v";
var LOCAL_PREFIX = "l";
var STACK_PREFIX = "s";
var ARGUMENT_PREFIX = "a";
var INLINE_CACHE_GETTER_PREFIX = "get";
var INLINE_CACHE_SETTER_PREFIX = "set";

var SAVED_SCOPE_NAME = "$SS";
var scopeName = new Identifier("$S");
var scopeObjectName = new Identifier("$O");
var globalScopeObjectName = new Identifier("$G");
var savedScopeName = new Identifier(SAVED_SCOPE_NAME);
var constantsName = new Identifier("$C");
var lastCaughtName = new Identifier("$E");
var exceptionName = new Identifier("$e");
var labelTestName = new Identifier("$label");
var labelConditionName = new Identifier("$condition");
var labelDeterminantName = new Identifier("$determinant");
var activationName = new Identifier("$activation");

/**
 * To embed object references in compiled code we index into globally accessible constant table [$C].
 * This table maintains an unique set of object references, each of which holds its own position in
 * the constant table, thus providing for fast lookup. To embed a reference to an object [k] we call
 * [constant(k)] which may generate the literal "$C[12]".
 */

var $C = [];

function generate(node) {
  return escodegen.generate(node, {base: "", indent: "  ", comment: true});
}

function notUndefined(x) {
  return x !== undefined;
}

var FlushStackReason = {
  EndOfBlock: 1,
  SetLocal: 2
};

var Compiler = (function () {

  function objectId(obj) {
    release || assert(obj);
    if (obj.hasOwnProperty("objectId")) {
      return obj.objectId;
    }
    var id = $C.length;
    Object.defineProperty(obj, "objectId", {value: id, writable: false, enumerable: false});
    $C.push(obj);
    return id;
  }

  Control.Break.prototype.compile = function (cx, state) {
    return cx.compileBreak(this, state);
  };

  Control.Continue.prototype.compile = function (cx, state) {
    return cx.compileContinue(this, state);
  };

  Control.Exit.prototype.compile = function (cx, state) {
    return cx.compileExit(this, state);
  };

  Control.LabelSwitch.prototype.compile = function (cx, state) {
    return cx.compileLabelSwitch(this, state);
  };

  Control.Seq.prototype.compile = function (cx, state) {
    return cx.compileSequence(this, state);
  };

  Bytecode.prototype.compile = function (cx, state) {
    return cx.compileBytecode(this, state);
  };

  Control.Loop.prototype.compile = function (cx, state) {
    return cx.compileLoop(this, state);
  };

  Control.Switch.prototype.compile = function (cx, state) {
    return cx.compileSwitch(this, state);
  };

  Control.If.prototype.compile = function (cx, state) {
    return cx.compileIf(this, state);
  };

  Control.Try.prototype.compile = function (cx, state) {
    return cx.compileTry(this, state);
  };

  var Constant = (function () {
    function constant(value) {
      this.value = value;
      if (value === undefined) {
        Identifier.call(this, "undefined");
      } else if (value !== null && typeof value === "object") {
        release || assert(value instanceof Multiname ||
                value instanceof Runtime ||
                value instanceof Domain ||
                value instanceof MethodInfo ||
                value instanceof ClassInfo ||
                value instanceof AbcFile ||
                value instanceof Array ||
                value instanceof CatchScopeObject ||
                value instanceof Scope ||
                value instanceof Global ||
                value instanceof Interface ||
                value.forceConstify === true,
                "Should not make constants from ", value);
        MemberExpression.call(this, constantsName, new Literal(objectId(value)), true);
      } else {
        if (typeof value === "number" && isNaN(value)) {
          Identifier.call(this, "NaN");
        } else if (value === Infinity) {
          Identifier.call(this, "Infinity");
        } else if (value === -Infinity) {
          UnaryExpression.call(this, "-", new Identifier("Infinity"));
        } else if (typeof value === "number" && (1 / value) < 0) {
          UnaryExpression.call(this, "-", new Literal(Math.abs(value)));
        } else {
          Literal.call(this, value);
        }
      }
    }
    constant.prototype.isEquivalent = function (other) {
      return other instanceof Constant && this.value === other.value;
    };
    return constant;
  })();

  function constant(value) {
    return new Constant(value);
  }

  function variableDeclaration(declarations) {
    return new VariableDeclaration("var", declarations);
  }

  function isIdentifierStart(c) {
    return (c === '$') || (c === '_') || (c === '\\') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
  }

  function isIdentifierPart(c) {
    return (c === '$') || (c === '_') || (c === '\\') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
           ((c >= '0') && (c <= '9'));
  }

  function isIdentifier(s) {
    if (!isIdentifierStart(s[0])) {
      return false;
    }
    for (var i = 1; i < s.length; i++) {
      if (!isIdentifierPart(s[i])) {
        return false;
      }
    }
    return true;
  }

  function property(obj) {
    var path = Array.prototype.slice.call(arguments, 1);
    path.forEach(function(x) {
      if (isIdentifier(x)) {
        obj = new MemberExpression(obj, new Identifier(x), false);
      } else {
        obj = new MemberExpression(obj, new Literal(x), true);
      }
    });
    return obj;
  }

  function call(callee, args) {
    release || assert(args instanceof Array);
    args.forEach(function (x) {
      release || assert(!(x instanceof Array));
      release || assert(x !== undefined);
    });
    return new CallExpression(callee, args);
  }

  function callCall(callee, args) {
    return call(property(callee, "call"), args);
  }

  function assignment(left, right) {
    release || assert(left && right);
    return new AssignmentExpression(left, "=", right);
  }

  function binary (operator, left, right) {
    return new BinaryExpression(operator.name, left, right);
  }

  function asInt32(value) {
    return binary(Operator.OR, value, constant(0));
  }

  function asUint32(value) {
    return binary(Operator.URSH, value, constant(0));
  }

  function id(name) {
    return new Identifier(name);
  }

  function checkType(value, type) {
    return new BinaryExpression("===",
      new UnaryExpression("typeof", value), new Literal(type));
  }

  function conditional(test, consequent, alternate) {
    return new ConditionalExpression(test, consequent, alternate);
  }

  function removeBlock(node) {
    if (node instanceof BlockStatement) {
      return node.body;
    }
    return node;
  }

  function compiler(abc) {
    this.abc = abc;
    this.writer = new IndentingWriter();
    this.verifier = new Verifier(abc);
  }

  /**
   * Abstract program state.
   */
  var State = (function () {
    var stateCounter = 0;
    function state() {
      this.stack = [];
      this.scopeHeight = 0;
      this.id = stateCounter ++;
    }
    state.prototype.clone = function clone() {
      var s = new State();
      s.stack = this.stack.slice(0);
      s.scopeHeight = this.scopeHeight;
      return s;
    };
    state.prototype.trace = function trace(writer) {
      writer.enter("state id: " + stateCounter + ", scopeHeight: " + this.scopeHeight + ", stack: {");
      for (var i = 0; i < this.stack.length; i++) {
        writer.writeLn(i + ": " + generate(this.stack[i]));
      }
      writer.leave("}");
    };
    return state;
  })();

  /**
   * Describes binary and unary operators.
   */
  var Operator = (function () {
    var map = {};

    function operator(name, fn, binary) {
      this.name = name;
      this.fn = fn;
      this.binary = binary;
      map[name] = this;
    }

    operator.ADD = new operator("+", function (l, r) { return l + r; }, true);
    operator.SUB = new operator("-", function (l, r) { return l - r; }, true);
    operator.MUL = new operator("*", function (l, r) { return l * r; }, true);
    operator.DIV = new operator("/", function (l, r) { return l / r; }, true);
    operator.MOD = new operator("%", function (l, r) { return l % r; }, true);
    operator.AND = new operator("&", function (l, r) { return l & r; }, true);
    operator.OR = new operator("|", function (l, r) { return l | r; }, true);
    operator.XOR = new operator("^", function (l, r) { return l ^ r; }, true);
    operator.LSH = new operator("<<", function (l, r) { return l << r; }, true);
    operator.RSH = new operator(">>", function (l, r) { return l >> r; }, true);
    operator.URSH = new operator(">>>", function (l, r) { return l >>> r; }, true);
    operator.SEQ = new operator("===", function (l, r) { return l === r; }, true);
    operator.SNE = new operator("!==", function (l, r) { return l !== r; }, true);
    operator.EQ = new operator("==", function (l, r) { return l == r; }, true);
    operator.NE = new operator("!=", function (l, r) { return l != r; }, true);
    operator.LE = new operator("<=", function (l, r) { return l <= r; }, true);
    operator.GT = new operator(">", function (l, r) { return l > r; }, true);
    operator.LT = new operator("<", function (l, r) { return l < r; }, true);
    operator.GE = new operator(">=", function (l, r) { return l >= r; }, true);
    operator.BITWISE_NOT = new operator("~", function (a) { return ~a; }, false);
    operator.NEG = new operator("-", function (a) { return -a; }, false);
    operator.TRUE = new operator("!!", function (a) { return !!a; }, false);
    operator.FALSE = new operator("!", function (a) { return !a; }, false);

    function linkOpposites(a, b) {
      a.not = b;
      b.not = a;
    }

    /**
     * Note that arithmetic comparisons aren't partial orders and cannot be
     * negated to each other.
     */

    linkOpposites(operator.SEQ, operator.SNE);
    linkOpposites(operator.EQ, operator.NE);
    linkOpposites(operator.TRUE, operator.FALSE);

    operator.fromName = function fromName(name) {
      return map[name];
    };

    operator.prototype.isBinary = function isBinary() {
      return this.binary;
    };

    operator.prototype.toString = function toString() {
      return this.name;
    };
    return operator;
  })();

  function negate(node) {
    release || assert(node instanceof BinaryExpression || node instanceof UnaryExpression);
    var left = node instanceof BinaryExpression ? node.left : node.argument;
    var right = node.right;
    var operator = Operator.fromName(node.operator);
    if (operator === Operator.EQ && right instanceof Literal && right.value === false) {
      return left;
    }
    if (operator === Operator.FALSE) {
      return left;
    }
    if (operator.not) {
      if (node instanceof BinaryExpression) {
        return new BinaryExpression(operator.not.name, left, right);
      } else {
        return new UnaryExpression(operator.not.name, left);
      }
    }
    return new UnaryExpression(Operator.FALSE.name, node);
  }

  function tryFallthrough(nothingThrownLabel, body) {
    return new IfStatement(new BinaryExpression("===", labelTestName, constant(nothingThrownLabel)), body);
  }

  var FindProperty = (function () {
    function findProperty(multiname, domain, strict) {
      this.strict = strict;
      this.multiname = multiname;
      var args = [this.multiname, domain, new Literal(this.strict)];
      CallExpression.call(this, property(scopeName, "findProperty"), args);
    }
    findProperty.prototype = Object.create(CallExpression.prototype);
    findProperty.prototype.isEquivalent = function isEquivalent(other) {
      return other instanceof findProperty &&
             this.multiname.isEquivalent(other.multiname) &&
             this.strict === other.strict;
    };
    return findProperty;
  })();

  /**
   * Wrapper around a named local variable.
   */
  var Variable = (function () {
    function variable(name) {
      Identifier.call(this, name);
    }
    variable.prototype = Object.create(Identifier.prototype);
    variable.prototype.toString = function toString() {
      return this.name;
    };
    variable.prototype.isEquivalent = function isEquivalent(other) {
      return other instanceof variable && this.name === other.name;
    };
    return variable;
  })();

  /**
   * Keeps track of a pool of variables that may be reused.
   */
  var VariablePool = (function () {
    function variablePool() {
      this.count = 0;
      this.used = [];
      this.available = [];
    }
    variablePool.prototype.acquire = function () {
      if (!this.available.empty()) {
        return this.available.pop();
      }
      var variable = new Variable(VAR_PREFIX + this.count++);
      this.used.push(variable);
      return variable;
    };
    variablePool.prototype.release = function (variable) {
      release || assert(this.used.contains(variable));
      this.available.push(variable);
    };
    variablePool.prototype.releaseAll = function () {
      this.available = this.available.concat(this.used);
      this.used = [];
    };
    return variablePool;
  })();

  /**
   * Common subexpression elimination is only used to CSE scope lookups for now,
   * use it more aggressively. Each basic block maintains a list of values which
   * are checked whenever new values are added to the list. If a [equivalent] value
   * already exists in the list, the old value is returned. The values are first
   * looked up in the current list, then in the parent's (immediate dominator) list.
   */
  var CSE = (function () {
    function cse(parent, variablePool) {
      this.parent = parent;
      this.variablePool = variablePool;
      this.values = [];
    }

    /**
     * Finds and returns an equivalent value or returns null if not found.
     * If |allocate| is true and an equivalent value is not found, then
     * a variable is allocated for the current value and the original value
     * is returned.
     */
    cse.prototype.get = function get(value, allocate) {
      if (value instanceof Variable || value instanceof Literal) {
        return value;
      }
      var values = this.values;
      for (var i = values.length - 1; i >= 0; i--) {
        var other = values[i];
        if (value.isEquivalent(other)) {
          release || assert(other.variable);
          return other;
        }
      }
      if (this.parent) {
        var otherValue = this.parent.get(value, false);
        if (otherValue) {
          return otherValue;
        }
      }
      if (!allocate) {
        return null;
      }
      value.variable = this.variablePool.acquire();
      this.values.push(value);
      return value;
    };

    cse.prototype.reset = function reset() {
      this.values = [];
      this.variablePool.releaseAll();
    };

    return cse;
  })();

  var Compilation = (function () {

    function compilation(compiler, methodInfo, scope, hasDynamicScope) {
      this.compiler = compiler;
      var abc = this.compiler.abc;
      var mi = this.methodInfo = methodInfo;
      var parameterCount = mi.parameters.length;
      this.bytecodes = methodInfo.analysis.bytecodes;
      this.state = new State();
      this.variablePool = new VariablePool(VAR_PREFIX);
      this.temporary = [];
      this.cachedScopes = [];

      /* Initialize local variables, first local is the |this| reference. */
      this.local = [new Variable("this")];

      var freeVariableNames = "abcdefghijklmnopqrstuvwxyz".split("");

      /* Create variables for the method's parameters. */
      for (var i = 0; i < parameterCount; i++) {
        var name = ARGUMENT_PREFIX + mi.parameters[i].name;
        this.local.push(new Variable(name));
      }

      var freshVariableCount = 0;

      function newVariableName() {
        var name = null;
        for (var i = 0; i < freeVariableNames.length; i++) {
          if ((name = freeVariableNames[i])) {
            delete freeVariableNames[i];
            return name;
          }
        }
        return LOCAL_PREFIX + freshVariableCount++;
      }

      /* Create variables for the method's remaining locals. */
      for (var i = parameterCount; i < mi.localCount; i++) {
        this.local.push(new Variable(newVariableName()));
      }

      this.prologue = [];

      this.prologue.push(new ExpressionStatement(
        call(property(id("Runtime"), "stack", "push"), [constant(abc.runtime)])));

      if (!hasDynamicScope) {
        // TODO: Here we also need to take care of the |this| pointer since it may
        // be equal to the |jsGlobal|. We should only do this if it's ever used.
        this.prologue.push(variableDeclaration([
          new VariableDeclarator(savedScopeName, constant(scope)),
        ]));
      }

      this.prologue.push(variableDeclaration([
        new VariableDeclarator(scopeName, savedScopeName),
        new VariableDeclarator(scopeObjectName, property(scopeName, "object")),
        new VariableDeclarator(globalScopeObjectName, property(scopeName, "global", "object")),
        new VariableDeclarator(scopeName, savedScopeName)
      ]));

      /* Declare local variables that aren't parameters or this. */
      if (this.local.length > parameterCount + 1) {
        this.prologue.push(variableDeclaration(this.local.slice(parameterCount + 1).map(function (x) {
          return new VariableDeclarator(x, null);
        })));
      }

      if (mi.needsRest() || mi.needsArguments()) {
        this.prologue.push(new ExpressionStatement(
          assignment(this.local[parameterCount + 1],
                     call(property(id("Array"), "prototype", "slice", "call"),
                          [id("arguments"), constant(mi.needsRest() ? parameterCount + 1 : 1)]))));
      }

      /* Initialize default arguments, and coerce arguments passed. */
      var argumentCount = property(id("arguments"), "length");
      var parameterIndexOffset = hasDynamicScope ? 2 : 1;
      for (var i = 0; i < parameterCount; i++) {
        var parameter = mi.parameters[i];
        var value = parameter.value;
        var local = this.local[i + 1];
        if (value !== undefined) {
          this.prologue.push(new IfStatement(binary(Operator.LT, argumentCount, constant(i + parameterIndexOffset)),
                                             new ExpressionStatement(assignment(local, constant(value))),
                                             null));
        }

        if (parameter.type && !parameter.type.isAnyName()) {
          var type = abc.domain.getProperty(parameter.type, true, true);
          if (type) {
            var coerced = assignment(local, call(id("coerce"), [local, constant(type)]));
            this.prologue.push(new ExpressionStatement(coerced));
          } else {
            // TODO: We should have a type here. Most likely we are compiling a constructor that needs
            // to get its own class type and this is not yet available because we haven't yet fully
            // constructed the class.
          }
        }
      }
    }

    compilation.prototype.compile = function compile() {
      var node = this.methodInfo.analysis.controlTree.compile(this, this.state).node;
      release || assert(node instanceof BlockStatement);
      if (this.temporary.length) {
        this.prologue.push(variableDeclaration(this.temporary.filter(notUndefined).map(function (x) {
          return new VariableDeclarator(x, null);
        })));
      }
      var usedVariables = this.variablePool.used;
      if (usedVariables.length) {
        this.prologue.push(variableDeclaration(usedVariables.map(function (x) {
          return new VariableDeclarator(x, null);
        })));
      }
      var cachedScopes = this.cachedScopes;
      for (var i = 0; i < cachedScopes.length; i++) {
        if (cachedScopes[i]) {
          var name = savedScopeName;
          for (var j = 0; j < i; j++) {
            name = property(name, "parent");
          }
          name = property(name, "object");
          this.prologue.push(variableDeclaration([
            new VariableDeclarator(cachedScopes[i], name)
          ]));
        }
      }
      Array.prototype.unshift.apply(node.body, this.prologue);
      return node;
    };

    compilation.prototype.compileLabelSwitch = function compileLabelSwitch(item, state) {
      var node = null;
      var firstCase = true;

      function labelEq(labelId) {
        release || assert(typeof labelId === "number");
        return new BinaryExpression("===", labelTestName, new Literal(labelId));
      }

      for (var i = item.cases.length - 1; i >= 0; i--) {
        var c = item.cases[i];
        var labels = c.labels;

        var labelExpr = labelEq(labels[0]);

        for (var j = 1; j < labels.length; j++) {
          labelExpr = new BinaryExpression("||", labelExpr, labelEq(labels[j]));
        }

        node = new IfStatement(labelExpr,
                               c.body ? c.body.compile(this, state).node : new BlockStatement(),
                               node);
      }
      return {node: node, state: state};
    };

    function labelTestBody(item) {
      var body = [];
      if (item.label) {
        body.push(variableDeclaration([
          new VariableDeclarator(labelTestName, new Literal(item.label))
        ]));
      }
      return body;
    }

    compilation.prototype.compileContinue = function compileContinue(item, state) {
      var body = labelTestBody(item);
      body.push(new ContinueStatement(null));
      return {node: new BlockStatement(body), state: state};
    };

    compilation.prototype.compileBreak = function compileBreak(item, state) {
      var body = labelTestBody(item);
      body.push(new BreakStatement(null));
      return {node: new BlockStatement(body), state: state};
    };

    compilation.prototype.compileExit = function compileExit(item, state) {
      var body = labelTestBody(item);
      return {node: new BlockStatement(body), state: state};
    };

    compilation.prototype.compileSequence = function compileSequence(item, state) {
      var cx = this;
      var body = [];
      item.body.forEach(function (x) {
        var result = x.compile(cx, state);
        if (result.node instanceof BlockStatement) {
          body = body.concat(result.node.body);
        } else {
          body.push(result.node);
        }
        state = result.state;
      });
      return {node: new BlockStatement(body), state: state};
    };

    compilation.prototype.compileLoop = function compileLoop(item, state) {
      var br = item.body.compile(this, state);
      return {node: new WhileStatement(constant(true), br.node), state: state};
    };

    compilation.prototype.compileSwitch = function compileSwitch(item, state) {
      var dt = item.determinant.compile(this, state);
      release || assert(dt.determinant);

      var cases = [];
      item.cases.forEach(function (x) {
        var result;
        if (x.body) {
          result = x.body.compile(this, dt.state.clone());
          // TODO: Merge states.
          release || assert(result.state.stack.length === 0);
        }
        cases.push(new SwitchCase(typeof x.index === "number" ? new Literal(x.index) : undefined, result ? [result.node] : []));
      }, this);

      if (item.nothingThrownLabel) {
        var ft = tryFallthrough(item.nothingThrownLabel, new SwitchStatement(labelDeterminantName, cases, false));
        dt.node = new BlockStatement([dt.node, ft]);
      } else {
        dt.node.body.push(new SwitchStatement(dt.determinant, cases, false));
      }

      return {node: dt.node, state: state};
    };

    compilation.prototype.compileIf = function compileIf(item, state) {
      var cr = item.cond.compile(this, state);
      var tr = null, er = null;
      if (item.then) {
        tr = item.then.compile(this, cr.state.clone());
      }
      if (item.else) {
        er = item.else.compile(this, cr.state.clone());
      }
      release || assert(tr || er);

      var node;
      if (item.nothingThrownLabel) {
        var condition;
        if (item.negated) {
          condition = new UnaryExpression(Operator.FALSE.name, labelConditionName);
        } else {
          condition = labelConditionName;
        }
        var ft = tryFallthrough(item.nothingThrownLabel,
                                new IfStatement(condition, tr ? tr.node : new BlockStatement([]),
                                                er ? er.node : null));
        cr.node = new BlockStatement([cr.node, ft]);
      } else {
        var condition = item.negated ? negate(cr.condition) : cr.condition;
        cr.node.body.push(new IfStatement(condition, tr ? tr.node : new BlockStatement([]), er ? er.node : null));
      }

      return {node: cr.node, state: (tr || er).state};
    };

    compilation.prototype.compileTry = function compileTry(item, state) {
      var br = item.body.compile(this, state);
      var catches = [];

      if (br.condition) {
        br.node.body.push(new ExpressionStatement(assignment(labelConditionName, br.condition)));
      }

      if (br.determinant) {
        br.node.body.push(new ExpressionStatement(assignment(labelDeterminantName, br.determinant)));
      }

      if (item.nothingThrownLabel > 0) {
        var nothingThrownLabel = variableDeclaration([
          new VariableDeclarator(labelTestName, id(item.nothingThrownLabel))
        ]);
        if (br.node instanceof BlockStatement) {
          br.node.body.push(nothingThrownLabel);
        } else {
          br.node = new BlockStatement([br.node, nothingThrownLabel]);
        }
      }

      var assign = variableDeclaration([new VariableDeclarator(lastCaughtName, exceptionName)]);

      var catchIf = null;
      var catchElse;
      item.catches.forEach(function (x) {
        var cr = x.body.compile(this, state);

        if (x.typeName) {
          var type = this.compiler.abc.domain.getProperty(x.typeName, true, true);
          var checkType = call(property(constant(type), "isInstance"), [exceptionName]);
          if (catchIf) {
            catchIf.alternate = new IfStatement(checkType, cr.node, null);
          } else {
            catchIf = new IfStatement(checkType, cr.node, null);
          }
        } else if (!catchElse) {
          // We ignore all the but the first unconditional catch. Finally
          // blocks generate extraneous unconditional catches. I don't even
          // know if this is right.
          catchElse = cr.node;
        }
      }, this);

      if (catchElse && catchIf) {
        catchIf.alternate = catchElse;
      } else {
        catchIf = catchElse;
      }

      var catchBody;
      if (catchIf instanceof BlockStatement) {
        catchIf.body.unshift(assign);
        catchBody = catchIf;
      } else {
        catchBody = new BlockStatement([assign, catchIf]);
      }

      var cc = new CatchClause(exceptionName, null, catchBody);
      return {node: new TryStatement(br.node, [cc], null), inner: br, state: state};
    };

    compilation.prototype.compileBytecode = function compileBytecode(block, state) {
      var writer = traceLevel.value <= 2 ? null : this.compiler.writer;
      if (writer) {
        writer.enter("block " + block.blockId + ", dom: " + block.dominator.blockId + " [" + block.position + "-" + block.end.position + "] {");
        writer.leave("}");
      }

      var body = [];
      var local = this.local;
      var temporary = this.temporary;
      var cachedScopes = this.cachedScopes;

      var abc = this.compiler.abc;
      var ints = abc.constantPool.ints;
      var uints = abc.constantPool.uints;
      var doubles = abc.constantPool.doubles;
      var strings = abc.constantPool.strings;
      var methods = abc.methods;
      var multinames = abc.constantPool.multinames;
      var runtime = abc.runtime;
      var exceptions = this.methodInfo.exceptions;

      var savedScope = this.savedScope;
      var multiname, args, value, obj, qn, ns, name, type, factory, index;

      var storedComments = [];

      function classObject() {
        return property(savedScopeName, "object");
      }

      function superClassInstanceObject() {
        return property(classObject(), "baseClass", "instanceNoInitialize");
      }

      function superOf(obj) {
        return property(obj, "public$constructor", "baseClass", "instance", "prototype");
      }

      function runtimeProperty(propertyName) {
        var result = constant(abc.runtime);
        if (propertyName) {
          result = property(result, propertyName);
        }
        return result;
      }

      function push(value) {
        release || assert(typeof value !== "string");
        bc.ti && (value.ti = bc.ti);
        state.stack.push(value);
      }

      function pop() {
        return state.stack.pop();
      }

      function popMany(count) {
        return state.stack.popMany(count);
      }

      function scopeAt(scopeDepth) {
        if (scopeDepth === 0) {
          return scopeObjectName;
        }
        var scope = scopeName;
        if (scopeDepth > state.scopeHeight) {
          scopeDepth -= state.scopeHeight;
          scope = savedScopeName;
        }
        for (var i = 0; i < scopeDepth; i++) {
          scope = property(scope, "parent");
        }
        return property(scope, "object");
      }

      function cseValue(value) {
        if (block.cse) {
          var otherValue = block.cse.get(value, true);
          if (otherValue === value) {
            // flushStack();
            emit(assignment(value.variable, value));
            value.variable.value = value;
            // print("CSE: " + generate(value) + " -> " + value.variable);
          }
          return otherValue.variable;
        }
        return value;
      }

      function flushScope() {
        if (block.cse) {
          block.cse.reset();
        }
      }

      function pushScope(obj, isWith) {
        emit(assignment(scopeName, new NewExpression(id("Scope"), [scopeName, obj, constant(isWith)])));
        emit(assignment(scopeObjectName, property(scopeName, "object")));
        state.scopeHeight += 1;
      }

      function setLocal(index) {
        release || assert(state.stack.length);
        var value = pop();
        flushStack(FlushStackReason.SetLocal);
        emit(assignment(local[index], value));
        local[index].ti = value.ti;
      }

      function duplicate(value) {
        var temp = getTemporary(state.stack.length);
        push(assignment(temp, value));
        push(temp);
      }

      function popValue() {
        emit(pop());
      }

      function kill(index) {
        flushStack(FlushStackReason.SetLocal);
        emit(assignment(local[index], constant(undefined)));
      }

      function getSlot(obj, index, ti) {
        if (enableOpt.value && ti) {
          var trait = ti.trait;
          if (trait) {
            if (trait.isConst()) {
              push(constant(trait.value));
              return;
            }
            push(property(obj, Multiname.getQualifiedName(trait.name)));
            return;
          }
        }
        push(call(id("getSlot"), [obj, constant(index)]));
      }

      function setSlot(obj, index, value, ti) {
        flushStack();
        if (enableOpt.value && ti && ti.trait) {
          var trait = ti.trait;
          if (trait) {
            emit(assignment(property(obj, Multiname.getQualifiedName(trait.name)), value));
            return;
          }
        }
        emit(call(id("setSlot"), [obj, constant(index), value]));
      }

      function getSavedScopeObject(depth) {
        if (cachedScopes[depth]) {
          return cachedScopes[depth];
        }
        return cachedScopes[depth] = new Identifier("$O_" + depth);
      }

      function getTemporary(index) {
        if (index in temporary) {
          return temporary[index];
        }
        var t = id(STACK_PREFIX + index);
        t.isTemporary = true;
        return temporary[index] = t;
      }

      /**
       * Emits assignments that store stack expressions into temporaries.
       */
      function flushStack(reason) {
        for (var i = 0; i < state.stack.length; i++) {
          if (reason !== FlushStackReason.EndOfBlock) {
            if (state.stack[i] instanceof Constant) {
              continue;
            } else if (state.stack[i] instanceof Identifier) {
              if (reason !== FlushStackReason.SetLocal) {
                continue;
              }
            }
          }
          if (state.stack[i] !== getTemporary(i)) {
            emit(assignment(getTemporary(i), state.stack[i]));
            getTemporary(i).ti = state.stack[i].ti;
            state.stack[i] = getTemporary(i);
          }
        }
      }

      function emit(value) {
        if (!(value instanceof Statement)) {
          value = new ExpressionStatement(value);
        }
        if (storedComments.length > 0) {
          value.leadingComments = storedComments;
        }
        storedComments = [];
        body.push(value);
      }

      function printThing(context, thing) {
        emit(call(id("print"), [constant(context), thing]));
      }

      function emitComment(value) {
        storedComments.push({ type: 'Line', value: " " + value.toString() });
      }

      if (false && enableOpt.value) {
        if (block.dominator === block) {
          block.cse = new CSE(null, this.variablePool);
        } else {
          release || assert(block.dominator.cse, "Dominator should have a CSE map.");
          block.cse = new CSE(block.dominator.cse, this.variablePool);
        }
      }

      function expression(operator, intPlease) {
        var a, b;
        if (operator.isBinary()) {
          b = pop();
          a = pop();
          if (intPlease) {
            a = asInt32(a);
            b = asInt32(b);
          }
          push(new BinaryExpression(operator.name, a, b));
        } else {
          a = pop();
          if (intPlease) {
            a = asInt32(a);
          }
          push(new UnaryExpression(operator.name, a));
        }
      }

      var condition = null;
      var determinant = null;

      /**
       * Remembers the branch condition for this block, which is passed and used by the If control
       * node.
       */
      function setCondition(operator) {
        release || assert(condition === null);
        var b;
        if (operator.isBinary()) {
          b = pop();
        }
        var a = pop();
        if (b) {
          condition = new BinaryExpression(operator.name, a, b);
        } else {
          condition = new UnaryExpression(operator.name, a);
        }
      }

      function setNegatedCondition(operator) {
        setCondition(operator);
        condition = new UnaryExpression(Operator.FALSE.name, condition);
      }

      /**
       * Find the scope object containing the specified multiname.
       */
      function findProperty(multiname, strict) {
        var ti = bc.ti;
        if (ti) {
          if (ti.object) {
            return constant(ti.object);
          } else if (ti.scopeDepth !== undefined) {
            return scopeAt(ti.scopeDepth);
          }
        }
        return cseValue(new FindProperty(multiname, constant(abc.domain), strict));
      }

      function getProperty(obj, multiname) {
        Counter.count("getProperty");
        release || assert(!(multiname instanceof Multiname), multiname);

        if (multiname instanceof Constant && multiname.value instanceof Multiname) {
          if (Multiname.isQName(multiname.value)) {
            return property(obj, Multiname.getQualifiedName(multiname.value));
          }
        }

        var slowPath = call(id("getProperty"), [obj, multiname]);
        if (enableInlineCaching.value && multiname instanceof Constant) {
          var mn = multiname.value;
          if (mn.namespaces.length > 1) {
            var ic = InlineCacheManager.createInlineCache(mn);
            if (ic) {
              slowPath = call(id(ic), [obj]);
            }
          }
        }

        if (enableOpt.value) {
          if (multiname instanceof RuntimeMultiname) {
            var fastPath = new MemberExpression(obj, multiname.name, true);
            if (multiname.name.ti && multiname.name.ti.type.isNumeric()) {
              Counter.count("getProperty:computed");
              return fastPath;
            }
            Counter.count("getProperty:computed:guarded");
            return conditional(checkType(multiname.name, "number"), fastPath, slowPath);
          } else if (multiname instanceof Constant && bc.ti) {
            var propertyQName = bc.ti.trait ? Multiname.getQualifiedName(bc.ti.trait.name) : bc.ti.propertyQName;
            if (propertyQName) {
              return property(obj, propertyQName);
            }
          }
        }

        Counter.count("getProperty:slow");
        return slowPath;
      }

      function setProperty(obj, multiname, value, ti) {
        var slowPath = call(id("setProperty"), [obj, multiname, value]);
        Counter.count("setProperty");

        if (multiname instanceof Constant && multiname.value instanceof Multiname) {
          if (Multiname.isQName(multiname.value)) {
            return assignment(property(obj, Multiname.getQualifiedName(multiname.value)), value);
          }
        }

        if (enableInlineCaching.value && multiname instanceof Constant) {
          var mn = multiname.value;
          if (mn.namespaces.length > 1) {
            var ic = InlineCacheManager.createInlineCache(mn, true);
            if (ic) {
              slowPath = call(id(ic), [obj, value]);
            }
          }
        }

        if (enableOpt.value) {
          if (multiname instanceof RuntimeMultiname) {
            var fastPath = assignment(new MemberExpression(obj, multiname.name, true), value);
            if (multiname.name.ti && multiname.name.ti.type.isNumeric()) {
              Counter.count("setProperty:computed");
              return fastPath;
            }
            Counter.count("setProperty:computed:guarded");
            return conditional(checkType(multiname.name, "number"), fastPath, slowPath);
          } else if (multiname instanceof Constant && ti) {
            var propertyQName = ti.trait ? Multiname.getQualifiedName(ti.trait.name) : ti.propertyQName;
            if (propertyQName) {
              return assignment(property(obj, propertyQName), value);
            }
          }
        }

        Counter.count("setProperty:slow");
        return slowPath;
      }

      function getMultiname(index) {
        var multiname = multinames[index];
        release || assert(!multiname.isRuntime());
        var c = constant(multiname);
        c.multiname = multiname;
        return c;
      }

      var RuntimeMultiname = (function () {
        function runtimeMultiname(multiname, namespaces, name) {
          this.multiname = multiname;
          this.namespaces = namespaces;
          this.name = name;
          CallExpression.call(this, property(id("Multiname"), "getMultiname"), [namespaces, name]);
        }
        runtimeMultiname.prototype.isEquivalent = function isEquivalent(other) {
          return false;
        };
        return runtimeMultiname;
      })();

      function popMultiname(bc) {
        var multiname = multinames[bc.index];
        if (multiname.isRuntime()) {
          flushStack();
          var namespaces = constant(multiname.namespaces);
          var name = constant(multiname.name);
          if (multiname.isRuntimeName()) {
            name = pop();
          }
          if (multiname.isRuntimeNamespace()) {
            namespaces = pop();
          }
          return new RuntimeMultiname(multiname, namespaces, name);
        } else {
          return constant(multiname);
        }
      }

      // If this is a catch block, we need clear the stack, the scope stack,
      // unwind the runtime stack, and push the exception. We push the last
      // caught exception here based on the invariant that the restructuring
      // should have a trail of labels that leads from the JavaScript catch to
      // this catch.
      if (block.exception) {
        emit(new ExpressionStatement(call(property(id("Runtime"), "unwindStackTo"),
                                          [constant(abc.runtime)])));
        emit(assignment(scopeName, savedScopeName));
        flushScope();
        state.scopeHeight = -1;
        state.stack.length = 0;
        push(lastCaughtName);
      }

      var bytecodes = this.bytecodes;
      for (var bci = block.position, end = block.end.position; bci <= end; bci++) {
        var bc = bytecodes[bci];
        var op = bc.op;

        if (writer) {
          writer.writeLn(("bytecode bci: " + bci + ", originalBci: " + bc.originalPosition + ", " + bc).padRight(' ', 100) + " ti: " + bc.ti);
        }

        switch (op) {

        case OP_bkpt:           notImplemented(); break;
        case OP_throw:
          emit(new ThrowStatement(pop()));
          break;
        case OP_getsuper:
          multiname = popMultiname(bc);
          obj = pop();
          push(call(id("getSuper"), [obj, multiname]));
          break;
        case OP_setsuper:
          value = pop();
          multiname = popMultiname(bc);
          flushStack();
          obj = pop();
          emit(call(id("setSuper"), [obj, multiname, value]));
          break;
        case OP_dxns:           notImplemented(); break;
        case OP_dxnslate:       notImplemented(); break;
        case OP_kill:           kill(bc.index); break;
        case OP_lf32x4:         notImplemented(); break;
        case OP_sf32x4:         notImplemented(); break;
        case OP_ifnlt:          setNegatedCondition(Operator.LT); break;
        case OP_ifge:           setCondition(Operator.GE); break;
        case OP_ifnle:          setNegatedCondition(Operator.LE); break;
        case OP_ifgt:           setCondition(Operator.GT); break;
        case OP_ifngt:          setNegatedCondition(Operator.GT); break;
        case OP_ifle:           setCondition(Operator.LE); break;
        case OP_ifnge:          setNegatedCondition(Operator.GE); break;
        case OP_iflt:           setCondition(Operator.LT); break;
        case OP_jump:
          // NOP
          break;
        case OP_iftrue:
          setCondition(Operator.TRUE);
          break;
        case OP_iffalse:
          setCondition(Operator.FALSE);
          break;
        case OP_ifeq:           setCondition(Operator.EQ); break;
        case OP_ifne:           setCondition(Operator.NE); break;
        case OP_ifstricteq:     setCondition(Operator.SEQ); break;
        case OP_ifstrictne:     setCondition(Operator.SNE); break;
        case OP_lookupswitch:
          determinant = pop();
          break;
        case OP_pushwith:
          flushStack();
          pushScope(pop(), true);
          break;
        case OP_popscope:
          flushStack();
          flushScope();
          emit(assignment(scopeName, property(scopeName, "parent")));
          emit(assignment(scopeObjectName, property(scopeName, "object")));
          state.scopeHeight -= 1;
          break;
        case OP_nextname:
          index = pop();
          obj = pop();
          push(call(id("nextName"), [obj, index]));
          break;
        case OP_nextvalue:
          index = pop();
          obj = pop();
          push(call(id("nextValue"), [obj, index]));
          break;
        case OP_hasnext:
          // TODO: Temporary implementation, totally broken.
          push(constant(false));
          break;
        case OP_hasnext2:
          flushStack();
          obj = local[bc.object];
          index = local[bc.index];
          emit(assignment(getTemporary(0), call(id("hasNext2"), [obj, index])));
          emit(assignment(local[bc.object], property(getTemporary(0), "object")));
          emit(assignment(local[bc.index], property(getTemporary(0), "index")));
          push(property(getTemporary(0), "index"));
          break;
        case OP_pushnull:       push(constant(null)); break;
        case OP_pushundefined:  push(constant(undefined)); break;
        case OP_pushfloat:      notImplemented(); break;
        case OP_pushbyte:       push(constant(bc.value)); break;
        case OP_pushshort:      push(constant(bc.value)); break;
        case OP_pushstring:     push(constant(strings[bc.index])); break;
        case OP_pushint:        push(constant(ints[bc.index])); break;
        case OP_pushuint:       push(constant(uints[bc.index])); break;
        case OP_pushdouble:     push(constant(doubles[bc.index])); break;
        case OP_pushtrue:       push(constant(true)); break;
        case OP_pushfalse:      push(constant(false)); break;
        case OP_pushnan:        push(constant(NaN)); break;
        case OP_pop:            popValue(); break;
        case OP_dup:            duplicate(pop()); break;
        case OP_swap:           state.stack.push(pop(), pop()); break;
        case OP_pushscope:
          flushStack();
          flushScope();
          pushScope(pop());
          break;
        case OP_pushnamespace:  notImplemented(); break;
        case OP_li8:            notImplemented(); break;
        case OP_li16:           notImplemented(); break;
        case OP_li32:           notImplemented(); break;
        case OP_lf32:           notImplemented(); break;
        case OP_lf64:           notImplemented(); break;
        case OP_si8:            notImplemented(); break;
        case OP_si16:           notImplemented(); break;
        case OP_si32:           notImplemented(); break;
        case OP_sf32:           notImplemented(); break;
        case OP_sf64:           notImplemented(); break;
        case OP_newfunction:
          push(call(runtimeProperty("createFunction"), [constant(methods[bc.index]), scopeName, constant(true)]));
          break;
        case OP_call:
          args = popMany(bc.argCount);
          obj = pop();
          push(callCall(pop(), [obj].concat(args)));
          break;
        case OP_construct:
          args = popMany(bc.argCount);
          obj = pop();
          push(new NewExpression(property(obj, "instance"), args));
          break;
        case OP_callmethod:     notImplemented(); break;
        case OP_callstatic:     notImplemented(); break;
        case OP_callsuper:
          flushStack();
          multiname = getMultiname(bc.index);
          args = popMany(bc.argCount);
          obj = pop();
          push(callCall(call(id("getSuper"), [obj, multiname]), [obj].concat(args)));
          break;
        case OP_callproperty:
          flushStack();
          args = popMany(bc.argCount);
          multiname = popMultiname(bc);
          obj = pop();
          push(callCall(getProperty(obj, multiname), [obj].concat(args)));
          break;
        case OP_returnvoid:
          flushStack();
          emit(call(property(id("Runtime"), "stack", "pop"), []));
          emit(new ReturnStatement());
          break;
        case OP_returnvalue:
          flushStack();
          emit(call(property(id("Runtime"), "stack", "pop"), []));
          emit(new ReturnStatement(pop()));
          break;
        case OP_constructsuper:
          args = popMany(bc.argCount);
          obj = pop();
          emit(callCall(superClassInstanceObject(), [obj].concat(args)));
          break;
        case OP_constructprop:
          args = popMany(bc.argCount);
          multiname = popMultiname(bc);
          obj = getProperty(pop(), multiname);
          push(new NewExpression(property(obj, "instance"), args));
          break;
        case OP_callsuperid:    notImplemented(); break;
        case OP_callproplex:
          flushStack();
          args = popMany(bc.argCount);
          multiname = popMultiname(bc);
          obj = pop();
          push(callCall(getProperty(obj, multiname), [constant(null)].concat(args)));
          break;
        case OP_callinterface:  notImplemented(); break;
        case OP_callsupervoid:
          flushStack();
          multiname = getMultiname(bc.index);
          args = popMany(bc.argCount);
          obj = pop();
          emit(callCall(call(id("getSuper"), [obj, multiname]), [obj].concat(args)));
          break;
        case OP_callpropvoid:
          args = popMany(bc.argCount);
          multiname = popMultiname(bc);
          obj = pop();
          emit(callCall(getProperty(obj, multiname), [obj].concat(args)));
          break;
        case OP_sxi1:           notImplemented(); break;
        case OP_sxi8:           notImplemented(); break;
        case OP_sxi16:          notImplemented(); break;
        case OP_applytype:
          args = popMany(bc.argCount);
          factory = pop();
          push(call(runtimeProperty("applyType"), [factory].concat(new ArrayExpression(args))));
          flushStack();
          break;
        case OP_pushfloat4:     notImplemented(); break;
        case OP_newobject:
          var properties = [];
          for (var i = 0; i < bc.argCount; i++) {
            var value = pop();
            var key = pop();
            release || assert(key.value !== undefined && typeof key.value !== "object");

            var mangledKey = Multiname.getPublicQualifiedName(key.value);
            properties.unshift(new T.Property(new Literal(mangledKey), value, "init"));
          }
          push(new ObjectExpression(properties));
          break;
        case OP_newarray:       push(new ArrayExpression(popMany(bc.argCount))); break;
        case OP_newactivation:
          release || assert(this.methodInfo.needsActivation());
          emit(variableDeclaration([
            new VariableDeclarator(activationName,
                                   call(runtimeProperty("createActivation"), [constant(this.methodInfo)]))
          ]));
          push(activationName);
          break;
        case OP_newclass:
          push(call(property(constant(abc), "runtime", "createClass"),
                    [constant(abc.classes[bc.index]), pop(), scopeName]));
          break;
        case OP_getdescendants:
          multiname = popMultiname(bc);
          obj = pop();
          push(call(id("getDescendants"), [multiname, obj]));
          break;
        case OP_newcatch:
          release || assert(exceptions[bc.index].scopeObject);
          flushStack();
          flushScope();
          push(constant(exceptions[bc.index].scopeObject));
          state.scopeHeight += 1;
          break;
        case OP_findpropstrict:
          multiname = popMultiname(bc);
          push(findProperty(multiname, true));
          break;
        case OP_findproperty:
          multiname = popMultiname(bc);
          push(findProperty(multiname, false));
          break;
        case OP_finddef:        notImplemented(); break;
        case OP_getlex:
          multiname = getMultiname(bc.index);
          push(getProperty(findProperty(multiname, true), multiname));
          break;
        case OP_initproperty:
        case OP_setproperty:
          value = pop();
          multiname = popMultiname(bc);
          flushStack();
          obj = pop();
          emit(setProperty(obj, multiname, value, bc.ti));
          break;
        case OP_getlocal:       push(local[bc.index]); break;
        case OP_setlocal:       setLocal(bc.index); break;
        case OP_getglobalscope:
          push(globalScopeObjectName);
          break;
        case OP_getscopeobject:
          var scopeDepth = (state.scopeHeight - 1) - bc.index;
          if (scopeDepth) {
            push(scopeAt(scopeDepth));
          } else {
            push(scopeObjectName);
          }
          break;
        case OP_getproperty:
          multiname = popMultiname(bc);
          obj = pop();
          push(getProperty(obj, multiname));
          break;
        case OP_getouterscope:      notImplemented(); break;
        case OP_setpropertylate:    notImplemented(); break;
        case OP_deleteproperty:
          multiname = popMultiname(bc);
          obj = pop();
          push(call(id("deleteProperty"), [obj, multiname]));
          flushStack();
          break;
        case OP_deletepropertylate: notImplemented(); break;
        case OP_getslot:
          var obj = pop();
          getSlot(obj, bc.index, bc.ti);
          break;
        case OP_setslot:
          value = pop();
          obj = pop();
          setSlot(obj, bc.index, value, bc.ti);
          break;
        case OP_getglobalslot:  notImplemented(); break;
        case OP_setglobalslot:  notImplemented(); break;
        case OP_convert_s:      push(call(id("toString"), [pop()])); break;
        case OP_esc_xelem:      notImplemented(); break;
        case OP_esc_xattr:      notImplemented(); break;
        case OP_coerce_i:
        case OP_convert_i:
          push(asInt32(pop()));
          break;
        case OP_coerce_u:
        case OP_convert_u:
          push(call(id("toUint"), [pop()]));
          break;
        case OP_coerce_d:
        case OP_convert_d:
          push(call(id("toDouble"), [pop()]));
          break;
        case OP_coerce_b:
        case OP_convert_b:
          push(new UnaryExpression(Operator.FALSE, new UnaryExpression(Operator.FALSE, pop())));
          break;
        case OP_convert_o:      notImplemented(); break;
        case OP_checkfilter:
          push(call(id("checkFilter"), [pop()]));
          break;
        case OP_convert_f:      notImplemented(); break;
        case OP_unplus:         notImplemented(); break;
        case OP_convert_f4:     notImplemented(); break;
        case OP_coerce:
          value = pop();
          multiname = getMultiname(bc.index);
          type = getProperty(findProperty(multiname, true), multiname);
          push(call(id("coerce"), [value, type]));
          break;
        case OP_coerce_a:       /* NOP */ break;
        case OP_coerce_s:       push(call(id("coerceString"), [pop()])); break;
        case OP_astype:         notImplemented(); break;
        case OP_astypelate:
          type = pop();
          value = pop();
          push(call(id("asInstance"), [value, type]));
          break;
        case OP_coerce_o:       notImplemented(); break;
        case OP_negate:         expression(Operator.NEG); break;
        case OP_increment:
          push(constant(1));
          expression(Operator.ADD);
          break;
        case OP_inclocal:
          emit(new UpdateExpression("++", local[bc.index]));
          break;
        case OP_decrement:
          push(constant(1));
          expression(Operator.SUB);
          break;
        case OP_declocal:
          emit(new UpdateExpression("--", local[bc.index]));
          break;
        case OP_typeof:
          push(call(id("typeOf"), [pop()]));
          break;
        case OP_not:            expression(Operator.FALSE); break;
        case OP_bitnot:         expression(Operator.BITWISE_NOT); break;
        case OP_add:            expression(Operator.ADD); break;
        case OP_subtract:       expression(Operator.SUB); break;
        case OP_multiply:       expression(Operator.MUL); break;
        case OP_divide:         expression(Operator.DIV); break;
        case OP_modulo:         expression(Operator.MOD); break;
        case OP_lshift:         expression(Operator.LSH); break;
        case OP_rshift:         expression(Operator.RSH); break;
        case OP_urshift:        expression(Operator.URSH); break;
        case OP_bitand:         expression(Operator.AND); break;
        case OP_bitor:          expression(Operator.OR); break;
        case OP_bitxor:         expression(Operator.XOR); break;
        case OP_equals:         expression(Operator.EQ); break;
        case OP_strictequals:   expression(Operator.SEQ); break;
        case OP_lessthan:       expression(Operator.LT); break;
        case OP_lessequals:     expression(Operator.LE); break;
        case OP_greaterthan:    expression(Operator.GT); break;
        case OP_greaterequals:  expression(Operator.GE); break;
        case OP_instanceof:
          type = pop();
          value = pop();
          push(call(property(type, "isInstanceOf"), [value]));
          break;
        case OP_istype:
          value = pop();
          multiname = getMultiname(bc.index);
          type = getProperty(findProperty(multiname, true), multiname);
          push(call(id("isInstance"), [value, type]));
          break;
        case OP_istypelate:
          type = pop();
          value = pop();
          push(call(id("isInstance"), [value, type]));
          break;
        case OP_in:             notImplemented(); break;
        case OP_increment_i:
          push(constant(1));
          expression(Operator.ADD, true);
          break;
        case OP_decrement_i:
          push(constant(1));
          expression(Operator.SUB, true);
          break;
        case OP_inclocal_i:
          emit(assignment(local[bc.index], binary(Operator.ADD, asInt32(local[bc.index]), constant(1))));
          break;
        case OP_declocal_i:
          emit(assignment(local[bc.index], binary(Operator.SUB, asInt32(local[bc.index]), constant(1))));
          break;
        case OP_negate_i:       expression(Operator.NEG, true); break;
        case OP_add_i:          expression(Operator.ADD, true); break;
        case OP_subtract_i:     expression(Operator.SUB, true); break;
        case OP_multiply_i:     expression(Operator.MUL, true); break;
        case OP_getlocal0:
        case OP_getlocal1:
        case OP_getlocal2:
        case OP_getlocal3:
          push(local[op - OP_getlocal0]);
          break;
        case OP_setlocal0:
        case OP_setlocal1:
        case OP_setlocal2:
        case OP_setlocal3:
          setLocal(op - OP_setlocal0);
          break;
        case OP_debug:
          /* NOP */
          break;
        case OP_debugline:
          emitComment("line: " + bc.lineNumber);
          break;
        case OP_debugfile:
          emitComment("file: " + strings[bc.index]);
          break;
        case OP_bkptline:       notImplemented(); break;
        case OP_timestamp:      notImplemented(); break;
        default:
          console.info("Not Implemented: " + bc);
        }
      }

      flushStack(FlushStackReason.EndOfBlock);

      if (storedComments.length > 0) {
        body.top().trailingComments = storedComments;
      }

      if (writer) {
        state.trace(writer);
        writer.enter("body: {");
        for (var i = 0; i < body.length; i++) {
          writer.writeLn(generate(body[i]));
        }
        writer.leave("}");
      }

      return {node: new BlockStatement(body), condition: condition, determinant: determinant, state: state};
    };

    return compilation;

  })();

  compiler.prototype.compileMethod = function compileMethod(methodInfo, hasDefaults, scope, hasDynamicScope) {
    release || assert(scope);
    release || assert(methodInfo.analysis);
    Counter.count("Compiler: Methods");
    Timer.start("Compiler");
    if (enableVerifier.value && scope.object) {
      // TODO: Can we verify even if |hadDynamicScope| is |true|?
      Timer.start("ver");
      this.verifier.verifyMethod(methodInfo, scope);
      Timer.stop();
    }
    var cx = new Compilation(this, methodInfo, scope, hasDynamicScope);
    Timer.start("ast");
    var node = cx.compile();
    Timer.stop();
    Timer.start("gen");
    var code = generate(node);
    Timer.stop();
    Timer.stop();
    return code;
  };

  compiler.Operator = Operator;

  return compiler;
})();

/**
 * Inline caching is used to optimize property access. In AS3, the property access expression |o.p| may be compiled as
 * |o.{ns0,ns1,ns2}::p| where {ns0, ns1, ns2} is a set of currently open namespaces. Usually, if we can't determine
 * the type of |o| then we can't resolve the multiname to a qname and we must emit a call to a slow |getProperty(o,
 * {ns0,ns1,ns2}::p)| function which performs a linear search over all qnames in the multiname until one is found.
 *
 * However, if we can prove that the name |p| only ever appears in the |ns1| namespace in any of the "currently" defined
 * traits, then we can resolve the multiname to |ns1$p| since it can't possibly resolve to any other namespace. Instead
 * of the slow |getProperty| call, we could just emit |o.ns1$p|. Unfortunately, this is not sound because another .swf
 * file may be loaded that defines a trait |p| in the namespace |ns0| which would invalidate our previous assumption. To
 * fix this, we instead generate a getter stub |get = function (o) { return o.ns1$p; }| that returns the value of |o.ns1$p|.
 * We then keep track of this stub and if at a later time our assumption is invalidated we patch it with another stub
 * that also checks the |ns0| namespace |get = function (o) { return o.ns1$p ? o.ns1$p : (o.ns0$p ? o.ns0$p : undefined); }|.
 *
 * Because the JS engine inlines short functions, we can expect that the getters / setter functions are inlined and
 * guarded with PICs, so in a sense we're implementing AS3 PICs on top of JS PICs.
 *
 */
var InlineCacheManager = (function () {
  var writer = new IndentingWriter();

  var inlineCacheSets = new Map();

  var InlineCacheSet = (function () {
    var inlineCacheCounter = 0;
    function inlineCacheSet(name) {
      this.name = name;
      this.namespaces = [];
      this.dirty = true;
      this.inlineCaches = [];
    }
    inlineCacheSet.prototype.update = function (namespace) {
      release || assert(namespace instanceof Namespace);
      var foundNewNamespace = true;
      var namespaces = this.namespaces;
      for (var i = 0; i < namespaces.length; i++) {
        if (namespaces[i][0].isEqualTo(namespace)) {
          namespaces[i][1] ++;
          foundNewNamespace = false;
          break;
        }
      }
      if (foundNewNamespace) {
        this.namespaces.push([namespace, 1]);
        release || assert(this.dirty, "TODO: Invalidate inline caches.");
      }
    };
    /**
     * Gets the intersection of the specified multiname's qnames and the current qnames for this name.
     */
    inlineCacheSet.prototype.getIntersection = function (mn) {
      var namespaces = this.namespaces.sort(function (a, b) {
        return a[1] - b[1];
      });
      var names = [];
      for (var i = 0; i < namespaces.length; i++) {
        var ns = namespaces[i][0];
        for (var j = 0; j < mn.namespaces.length; j++) {
          if (mn.namespaces[j].isEqualTo(ns)) {
            if (!ns.isDynamic()) {
              names.push(new Multiname([ns], mn.name));
            }
            break;
          }
        }
      }
      // The public dynamic namespace needs to be last.
      names.push(Multiname.getPublicQualifiedName(mn.name));
      return names;
    };
    inlineCacheSet.prototype.create = function (mn, isSetter) {
      this.dirty = false;
      var qns = this.getIntersection(mn);
      qns.reverse();
      var src;
      for (var i = 0; i < qns.length; i++) {
        var qn = Multiname.getQualifiedName(qns[i]);
        if (isSetter) {
          src = i === 0 ? 'o.' + qn + ' = v' :
                          '(o.' + qn + ' !== undefined || ("' + qn + '" in o)) ? o.' + qn + ' = v : (' + src + ')';
        } else {
          src = i === 0 ? 'o.' + qn :
                          '((x = o.' + qn + ') !== undefined || ("' + qn + '" in o)) ? x : (' + src + ')';
        }
      }
      release || assert(qns.length);
      var icName = (isSetter ? INLINE_CACHE_SETTER_PREFIX : INLINE_CACHE_GETTER_PREFIX) + (inlineCacheCounter ++);
      if (isSetter) {
        src = 'function ' + icName + '(o, v) { ' + src + '; }';
      } else {
        src = 'function ' + icName + '(o) { ' + (qns.length > 1 ? 'var x; ' : '') + 'return ' + src + '; }';
      }
      if (traceInlineCaching.value) {
        writer.writeLn("IC Stub: " + src);
      }
      jsGlobal[icName] = eval('[' + src + '][0]');
      this.inlineCaches.push(icName);
      return icName;
    };
    return inlineCacheSet;
  })();

  function updateTraits(traits) {
    traits.forEach(function (trait) {
      var name = trait.name.getName();
      var namespace = trait.name.getNamespace();
      if (!inlineCacheSets.has(name)) {
        inlineCacheSets.set(name, new InlineCacheSet(name));
      }
      var inlineCacheSet = inlineCacheSets.get(name);
      release || assert(inlineCacheSet, name);
      inlineCacheSet.update(namespace);
    });
  }

  return {
    createInlineCache: function createInlineCache(mn, isSetter) {
      release || assert(mn instanceof Multiname);
      release || assert(!mn.isAnyName() && !mn.isRuntimeName() && !mn.isRuntimeNamespace());
      release || assert(mn.namespaces.length > 1);
      var cache = mn.inlineCache || (mn.inlineCache = {});
      var cacheName = isSetter ? "setter" : "getter";
      if (cache[cacheName]) {
        return cache[cacheName];
      }
      var name = mn.getName();
      if (inlineCacheSets.has(name)) {
        var inlineCacheSet = inlineCacheSets.get(name);
        if (inlineCacheSet) {
          Counter.count("Compiler: Inline Cache")
          return cache[cacheName] = inlineCacheSet.create(mn, isSetter);
        }
      }
      return undefined;
    },
    /**
     * Called after an .abc file is loaded. This invalidates inline caches if they have been created.
     */
    updateInlineCaches: function updateInlineCaches(abc) {
      if (!enableInlineCaching.value) {
        return;
      }
      /* Collect traits from script, classes, instances and method activations. */
      abc.scripts.forEach(function (si) {
        updateTraits(si.traits);
      });
      abc.classes.forEach(function (ci) {
        updateTraits(ci.traits);
        updateTraits(ci.instanceInfo.traits);
      });
      abc.methods.forEach(function (mi) {
        if (mi.traits) {
          updateTraits(mi.traits);
        }
      });
      /* Trace stats. */
      if (traceInlineCaching.value) {
        for (var k in inlineCacheSets) {
          if (inlineCacheSets.has(k)) {
            var set = inlineCacheSets.get(k);
            writer.writeLn("IC Set: " + k + " - " + set.namespaces.map(function (x) {
              return x[0].qualifiedName + ": " + x[1];
            }).join(", "));
          }
        }
      }
    }
  };

})();
